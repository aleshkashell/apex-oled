package oled

import (
	"apex-oled/internal/bitset"
	"fmt"
	"image"
	"image/png"
	"io"
	"log"
	"os"
)

var DisplayWidth = 128
var DisplayHeight = 40
var OledPreamble = []byte{0x65}

func pixelsToPayload() {
	fmt.Println(DisplayWidth)
	fmt.Println(DisplayHeight)

}

func GetImageBytes() []byte {
	image.RegisterFormat("png", "png", png.Decode, png.DecodeConfig)
	file, err := os.Open("/home/aleshka/projects/golang/apex-oled/internal/oled/assets/grimm.png")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	pixels, err := getPixels(file)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(pixels)
	return PixelsToBytes(pixels)
	//return append(OledPreamble, PixelsToBytes(pixels)...)
}

func GetTestData() []byte {
	return []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x07, 0x9e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6e, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6c, 0xe1, 0x86, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7d, 0xb1, 0x86, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6d, 0xf1, 0x86, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6d, 0x81, 0x86, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6e, 0xf7, 0xff, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1c, 0x00, 0x00, 0x00, 0xce, 0x00, 0x00, 0x03, 0x38, 0x00, 0x00, 0x00, 0x18, 0x70, 0x00, 0x00,
		0x30, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
		0x7d, 0xbb, 0xbe, 0x01, 0xf7, 0x8e, 0x00, 0xe7, 0xde, 0x39, 0xb8, 0x0f, 0x78, 0xf3, 0x80, 0x00,
		0x30, 0xee, 0xdf, 0x00, 0xc6, 0xdb, 0x01, 0xb3, 0x1b, 0x6c, 0xe8, 0x1c, 0x19, 0xb6, 0xc0, 0x00,
		0x30, 0xc6, 0xd5, 0x00, 0xc6, 0xdf, 0x01, 0xb3, 0x1b, 0x7c, 0xc0, 0x0f, 0x19, 0xb7, 0xc0, 0x00,
		0x30, 0xc6, 0xd5, 0x00, 0xd6, 0xd8, 0x01, 0xb3, 0x5b, 0x60, 0xc0, 0x03, 0x99, 0xb6, 0x00, 0x00,
		0x7d, 0xe3, 0x95, 0x00, 0x76, 0xcf, 0x00, 0xe1, 0xdb, 0x3d, 0xe0, 0x1f, 0x7e, 0xfb, 0xc0, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x31, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x3b, 0x63, 0xc0, 0x3c, 0xef, 0x8e, 0x01, 0xf3, 0x9d, 0xfc, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6d, 0xb6, 0xc0, 0x71, 0xb7, 0xdb, 0x00, 0xc6, 0xcf, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x3d, 0xb6, 0xc0, 0x3d, 0xb5, 0x5f, 0x00, 0xc7, 0xc6, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6d, 0xb6, 0xc0, 0x0f, 0xb5, 0x58, 0x00, 0xde, 0x0f, 0x36, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7d, 0xb3, 0xe0, 0x7c, 0xe5, 0x4f, 0x00, 0x73, 0xdb, 0x9d, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
}

// Get the bi-dimensional pixel array
func getPixels(file io.Reader) ([][]Pixel, error) {
	img, _, err := image.Decode(file)

	if err != nil {
		return nil, err
	}

	bounds := img.Bounds()
	width, height := bounds.Max.X, bounds.Max.Y

	fmt.Println(width, height)
	var pixels [][]Pixel
	for y := 0; y < height; y++ {
		var row []Pixel
		for x := 0; x < width; x++ {
			row = append(row, rgbaToPixel(img.At(x, y).RGBA()))
		}
		//pixels = append(pixels, row)
		pixels = append(pixels, row)
	}

	return pixels, nil
}

func PixelsToBytes(pixels [][]Pixel) []byte {
	var result []byte
	var b byte = 0x00
	var counter uint = 8
	for _, line := range pixels {
		for _, p := range line {
			counter--
			if p.R > 155 {
				b = bitset.SetBit(b, counter)
			}
			if counter == 0 {
				result = append(result, b)
				b = 0x00
				counter = 8
			}
		}
	}
	return result
}

// img.At(x, y).RGBA() returns four uint32 values; we want a Pixel
func rgbaToPixel(r uint32, g uint32, b uint32, a uint32) Pixel {
	return Pixel{int(r / 257), int(g / 257), int(b / 257), int(a / 257)}
}

// Pixel struct example
type Pixel struct {
	R int
	G int
	B int
	A int
}

func PixelToByte(p Pixel) {

}
